; PUT
;	PUTC
;	PUTS


; PUTC
; P - (A) character "C"
; R - (A) character "R"
; places the single character C into the output buffer
; checks the write index and increments it as well
; stalls if no space is available to write
; on return, R = C
; return indicates that the character was successfully written

.L PUTC
	PHA			; push character to use acc
	LDA OUT_BUFFER_WI	; load wi to compare with wi
	INC			; checking wi + 1 = ri, inc wi
	AND 0X7F, I		; AND for correct range
.L _PUTC_CHECK_LOOP
	CMP OUT_BUFFER_RI	; is wi + 1 equal to ri?
	BEQ _PUTC_CHECK_LOOP	; if yes, keep looping and comparing until a spot opens
			; space opened up, can place the char now
	PLA			; get the character from stack
	PHA			; push again to make a copy for return val
	PHX			; push x for index use
	LDX OUT_BUFFER_WI	; load wi
	STA OUT_BUFFER, X	; store at buffer + wi
	TXA			; move wi to acc to do arithmetic
	INC			; increment index
	AND 0X7F, I		; make correct range
	STA OUT_BUFFER_WI	; store new wi back
	PLX			; pull x
	PLA			; pull char to return
	RTS			; return


;=================================================


; PUTS
; P - (VR0) pointer to string "P"
; R - none
; writes all characters in the string at P to the output buffer
; adds a newline in the buffer after all the characters
; return indicates writing success

.L PUTS
	PHA			; push acc
	PHY			; push y
	LDY 0, I		; load 0 for string index
.L _PUTS_LOOP
	LDA VR0, NY		; load character at index y from P
	BEQ _PUTS_LOOP_END	; if null character, end loop
			; not the null character, place it
	JSR PUTC		; put the character into the output buffer
	INY			; increment string index
	BRA _PUTS_LOOP		; redo loop
.L _PUTS_LOOP_END
	LDA ASCII_LF, I		; all chars were placed except null, newline now
	JSR PUTC		; write a line feed into the output buffer
	PLY			; pull y
	PLA			; pull acc
	RTS			; return
